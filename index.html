<!doctype html>
<html lang="en">
<head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>XML Tool — Tree, Editor & Visualizer</title>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;600&family=Fira+Code&display=swap" rel="stylesheet">
    <style>
      :root {
        --bg: #0f1720;
        --panel: #0b1220;
        --text: #e6eef6;
        --muted: #9aa4b2;
        --accent: #06b6d4;
        --success: #10b981;
        --danger: #ef4444;
        --warning: #f59e0b;
        --glass: rgba(255, 255, 255, 0.03);
        --border-light: rgba(255, 255, 255, 0.04);
        --border-dashed: rgba(255, 255, 255, 0.03);
        --row-alt: rgba(255, 255, 255, 0.04);
        --gradient-start: #065f73;
        --gradient-end: #0ea5a3;
        --app-bg-start: #071028;
        --app-bg-end: #071a2b;
        --tag: #5eead4;
        --attr-name: #93c5fd;
        --attr-value: #fde047;
        --comment: #6b7280;
      }

      .light-theme {
        --bg: #f8fafc;
        --panel: #ffffff;
        --text: #0f172a;
        --muted: #64748b;
        --accent: #0891b2;
        --success: #059669;
        --danger: #dc2626;
        --warning: #d97706;
        --glass: rgba(0, 0, 0, 0.03);
        --border-light: rgba(0, 0, 0, 0.08);
        --border-dashed: rgba(0, 0, 0, 0.1);
        --row-alt: rgba(0, 0, 0, 0.03);
        --gradient-start: #0891b2;
        --gradient-end: #14b8a6;
        --app-bg-start: #e0f2fe;
        --app-bg-end: #f0f9ff;
        --tag: #0d9488;
        --attr-name: #2563eb;
        --attr-value: #ca8a04;
        --comment: #9ca3af;
      }

      html, body {
        height: 100%;
        margin: 0;
        font-family: 'Inter', ui-sans-serif, system-ui, -apple-system, "Segoe UI", Roboto, "Helvetica Neue", Arial;
        background: linear-gradient(180deg, var(--app-bg-start) 0%, var(--app-bg-end) 100%);
        color: var(--text);
        transition: background-color 0.3s, color 0.3s;
        overflow: hidden;
      }

      .app {
        height: 100vh;
        display: grid;
        grid-template-rows: auto 1fr;
        gap: 12px;
        padding: 12px;
        box-sizing: border-box;
      }

      header { display: flex; align-items: center; gap: 12px; flex-wrap: wrap; }
      .brand { font-weight: 600; font-size: 1.1rem; }
      .controls { margin-left: auto; display: flex; gap: 8px; align-items: center; flex-wrap: wrap; }
      .btn {
        background: var(--glass);
        border: 1px solid var(--border-light);
        padding: 6px 12px;
        border-radius: 8px;
        color: var(--muted);
        cursor: pointer;
        font-size: 14px;
        display: flex;
        align-items: center;
        gap: 6px;
        transition: background-color 0.2s, color 0.2s, border-color 0.2s;
        white-space: nowrap;
      }
      .btn:hover { background: var(--border-light); color: var(--text); }
      .btn.primary { background: linear-gradient(90deg, var(--gradient-start), var(--gradient-end)); color: white; border: none; }
      
      main {
        display: grid;
        grid-template-columns: 360px 6px 1fr;
        gap: 8px;
        align-items: stretch;
        min-height: 0;
      }

      .pane {
        background: var(--panel);
        border-radius: 8px;
        padding: 12px;
        overflow: auto;
        border: 1px solid var(--border-light);
        transition: background-color 0.3s;
        display: flex;
        flex-direction: column;
        gap: 8px;
      }

      .split { cursor: col-resize; background: transparent; }
      
      .editor-container {
        flex-grow: 1;
        border: 1px dashed var(--border-dashed);
        border-radius: 6px;
        min-height: 0;
        overflow: hidden;
      }
      
      #editor { width: 100%; height: 100%; }
      
      .tree-container { 
        font-family: 'Fira Code', monospace; 
        font-size: 13px; 
        color: var(--muted); 
        flex-grow: 1; 
        overflow-y: auto;
        position: relative;
      }
      .node { 
        padding: 4px 6px; 
        border-radius: 6px; 
        display: flex; 
        gap: 4px; 
        align-items: center; 
        flex-wrap: nowrap; /* Default is no wrap */
        overflow: hidden;
        height: 28px; /* Set fixed height for non-wrapped state */
        box-sizing: border-box;
      }
      .node:hover { background: var(--glass); cursor: pointer; }
      
      .tree-container.tree-word-wrap .node {
        flex-wrap: wrap; /* Allow wrapping when class is applied */
        height: auto; /* Revert to auto height for wrapped state */
      }

      .node-tag { color: var(--tag); font-weight: 600;}
      .node-attr-name { color: var(--attr-name); }
      .node-attr-value { color: var(--attr-value); }
      .node-comment { color: var(--comment); font-style: italic; }
      .node-text { color: var(--text); white-space: pre-wrap; }

      ul { list-style: none; padding-left: 14px; margin: 6px 0; }
      
      .node-wrapper:nth-child(even) > .node { background-color: var(--row-alt); }
      .node-wrapper.collapsed > ul { display: none; }
      .toggler {
          display: inline-block;
          width: 1em;
          text-align: center;
          margin-right: 4px;
          transition: transform 0.15s ease;
          flex-shrink: 0;
          cursor: pointer;
      }
      .node-wrapper:not(.collapsed) .toggler { transform: rotate(90deg); }

      .badge { font-size: 12px; padding: 2px 6px; border-radius: 999px; background: var(--glass); color: var(--muted); }
      .status { font-size: 13px; color: var(--muted); }
      .error { color: var(--danger); }
      .success { color: var(--success); }
      .warning { color: var(--warning); }
      .footer { font-size: 13px; color: var(--muted); margin-top: auto; }
      .filedrop { 
        border: 2px dashed var(--border-dashed); 
        padding: 12px; 
        border-radius: 6px; 
        text-align: center; 
        color: var(--muted); 
        transition: border-color 0.2s;
        position: absolute;
        top: 0; left: 0; width: 100%; height: 100%;
        box-sizing: border-box;
        display: flex;
        align-items: center;
        justify-content: center;
        background: var(--panel);
        z-index: 5;
      }
      .small { font-size: 12px; }
      .search { padding: 6px; border-radius: 6px; border: 1px solid var(--border-light); background: transparent; color: var(--muted); width: 100%; box-sizing: border-box; }
      
      /* Visualization Panel */
      #vizPane {
        height: 400px;
        display: none; /* Hidden by default */
        position: relative;
        padding: 0;
        border-radius: 8px;
        border: 1px solid var(--border-dashed);
        background: var(--bg);
        overflow: hidden;
      }
      #vizPane.fullscreen {
        position: fixed; top: 0; left: 0; width: 100vw; height: 100vh; z-index: 1000; padding: 20px; box-sizing: border-box; background: var(--panel);
      }
      .viz-toolbar { position: absolute; top: 8px; left: 8px; z-index: 10; display: flex; gap: 8px; }
      #vizSvg { width: 100%; height: 100%; cursor: grab; }
      .viz-message { position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%); color: var(--muted); }
      .link { fill: none; stroke: var(--muted); stroke-opacity: 0.4; stroke-width: 1.5px; }
      .node-viz circle { stroke: var(--border-light); stroke-width: 1.5px; cursor: pointer; }
      .node-viz text { fill: var(--text); font-size: 10px; pointer-events: none; }
      .values-hidden .value-text { display: none; }
      
      #vizAttrPane {
        position: absolute;
        top: 45px;
        right: 8px;
        width: 220px;
        max-height: calc(100% - 53px);
        background: var(--panel);
        border: 1px solid var(--border-light);
        border-radius: 6px;
        padding: 8px;
        display: none;
        z-index: 20;
        overflow-y: auto;
        box-shadow: 0 4px 12px rgba(0,0,0,0.3);
        font-family: 'Fira Code', monospace;
      }
      #vizAttrContent table {
        width: 100%;
        border-collapse: collapse;
        font-size: 11px;
      }
      #vizAttrContent td {
        padding: 4px;
        border-bottom: 1px solid var(--border-dashed);
        vertical-align: top;
      }
      #vizAttrContent tr:last-child td {
        border-bottom: none;
      }
      #vizAttrContent td:first-child {
        color: var(--attr-name);
        font-weight: 600;
        padding-right: 8px;
      }
      #vizAttrContent td:last-child {
        color: var(--attr-value);
        word-break: break-all;
      }

      @media (max-width: 900px) {
        main { grid-template-columns: 1fr; grid-template-rows: 1fr 8px 1fr; }
        .split { cursor: row-resize; }
      }
    </style>
</head>
<body>
    <div class="app">
        <header>
            <div class="brand">XML Tool</div>
            <div class="status small">Tree, Editor & Visualizer</div>
            <div class="controls">
                <button id="btnValidate" class="btn">Validate</button>
                <button id="btnFormat" class="btn">Format</button>
                <label class="btn" title="Open file">
                    Open
                    <input id="fileInput" type="file" accept="application/xml, .xml,.txt" style="display:none" />
                </label>
                <button id="btnDownload" class="btn">Download</button>
                <button id="btnCopy" class="btn">Copy</button>
                <button id="btnWordWrap" class="btn">Word Wrap</button>
                <button id="btnToggleNetwork" class="btn">Network Graph</button>
                <button id="btnToggleTree" class="btn">Tree Layout</button>
                <button id="btnTheme" class="btn"></button>
            </div>
        </header>

        <main>
            <section class="pane left">
                <div style="display:flex; gap: 8px; align-items: center; flex-wrap: wrap;">
                    <input id="search" class="search" placeholder="Filter tags..." style="flex-grow: 1; min-width: 120px;" />
                    <button id="btnTreeWrap" class="btn small">Wrap</button>
                    <div class="badge">Nodes: <span id="nodeCount">0</span></div>
                </div>
                <div class="tree-container">
                    <div id="treeRoot"></div>
                    <div class="filedrop" id="filedrop">Paste XML on the right or open a file. Drop a .xml here.</div>
                </div>
                <div class="footer">A tool for viewing and editing XML.</div>
            </section>

            <div class="split" id="splitter"></div>

            <section class="pane editor">
                 <div id="editorContainer" class="editor-container">
                    <div id="editor"></div>
                </div>
                <div style="display:flex;gap:8px;align-items:center">
                    <button id="btnBeautify" class="btn primary">Format</button>
                    <button id="btnClear" class="btn">Clear</button>
                    <div style="margin-left:auto" class="status" id="editorStatus"></div>
                </div>
                <div id="vizPane">
                    <div class="viz-toolbar">
                        <button id="btnToggleValues" class="btn small">Toggle Values</button>
                        <button id="btnToggleFullscreen" class="btn small">Full Screen</button>
                        <button id="btnCloseViz" class="btn small">Close</button>
                    </div>
                    <svg id="vizSvg"></svg>
                    <div id="vizMessage" class="viz-message">Load valid XML to generate a graph.</div>
                    <div id="vizAttrPane" class="small">
                        <div id="vizAttrHeader" style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 8px;">
                            <strong>Attributes</strong>
                            <span id="vizAttrClose" style="cursor: pointer; font-size: 16px; line-height: 1;">&times;</span>
                        </div>
                        <div id="vizAttrContent"></div>
                    </div>
                </div>
            </section>
        </main>
    </div>

    <!-- D3.js Library -->
    <script src="https://d3js.org/d3.v7.min.js"></script>
    <!-- Monaco Editor Loader -->
    <script src="https://cdn.jsdelivr.net/npm/monaco-editor@0.33.0/min/vs/loader.js"></script>
    <script>
        document.addEventListener('DOMContentLoaded', () => {
            /**
             * Main application module for the XML Tool.
             */
            const XMLTool = {
                els: {},
                state: {
                    monacoEditor: null,
                    xmlDoc: null,
                    isSplitterDown: false,
                    currentViz: 'none',
                    networkTransform: d3.zoomIdentity,
                    treeTransform: d3.zoomIdentity,
                    pinnedVizNodeData: null
                },
                icons: {
                    sun: `<svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"></circle><line x1="12" y1="1" x2="12" y2="3"></line><line x1="12" y1="21" x2="12" y2="23"></line><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"></line><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"></line><line x1="1" y1="12" x2="3" y2="12"></line><line x1="21" y1="12" x2="23" y2="12"></line><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"></line><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"></line></svg>`,
                    moon: `<svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1 1 11.21 3 7 7 0 0 0 21 12.79z"></path></svg>`
                },
                init() {
                    this.cacheDom();
                    this.initEditor();
                    this.applyInitialSettings();
                    this.bindEvents();
                },
                cacheDom() {
                    const ids = [
                        'treeRoot', 'nodeCount', 'fileInput', 'filedrop', 'btnBeautify', 'btnValidate', 
                        'btnFormat', 'btnCopy', 'btnDownload', 'btnClear', 'search', 'editorStatus', 
                        'btnTheme', 'btnWordWrap', 'editorContainer', 'splitter', 'vizPane', 'vizMessage',
                        'btnToggleNetwork', 'btnToggleTree', 'btnToggleValues', 'btnToggleFullscreen', 'btnCloseViz',
                        'btnTreeWrap', 'vizAttrPane', 'vizAttrContent', 'vizAttrClose'
                    ];
                    ids.forEach(id => this.els[id] = document.getElementById(id));
                    this.els.vizSvg = d3.select("#vizSvg");
                },
                initEditor() {
                    const savedTheme = localStorage.getItem('xml-tool-theme') || (window.matchMedia('(prefers-color-scheme: light)').matches ? 'light' : 'dark');
                    const savedWordWrap = localStorage.getItem('xml-tool-word-wrap') === 'true';

                    require.config({ paths: { 'vs': 'https://cdn.jsdelivr.net/npm/monaco-editor@0.33.0/min/vs' } });
                    require(['vs/editor/editor.main'], () => {
                        this.state.monacoEditor = monaco.editor.create(document.getElementById('editor'), {
                            language: 'xml',
                            theme: savedTheme === 'light' ? 'vs' : 'vs-dark',
                            automaticLayout: false, // Set to false to manually handle layout
                            wordWrap: savedWordWrap ? 'on' : 'off',
                            minimap: { enabled: false },
                            scrollbar: { verticalScrollbarSize: 10, horizontalScrollbarSize: 10 }
                        });

                        const editorContainer = this.els.editorContainer;
                        const debouncedLayout = this.utils.debounce(() => {
                            if (this.state.monacoEditor) {
                                this.state.monacoEditor.layout();
                            }
                        }, 50);
                        const resizeObserver = new ResizeObserver(debouncedLayout);
                        resizeObserver.observe(editorContainer);

                        this.state.monacoEditor.onDidChangeModelContent(this.utils.debounce(() => this.handlers.handleUpdateFromEditor(), 400));
                        this.loadSampleData();
                        this.applyTheme(savedTheme);
                    });
                },
                applyInitialSettings() {
                    const savedTheme = localStorage.getItem('xml-tool-theme') || (window.matchMedia('(prefers-color-scheme: light)').matches ? 'light' : 'dark');
                    this.applyTheme(savedTheme);
                    
                    const savedWordWrap = localStorage.getItem('xml-tool-word-wrap') === 'true';
                    this.els.btnWordWrap.textContent = savedWordWrap ? 'No Wrap' : 'Word Wrap';

                    const savedTreeWrap = localStorage.getItem('xml-tool-tree-wrap') === 'true';
                    if (savedTreeWrap) {
                        this.els.treeRoot.parentElement.classList.add('tree-word-wrap');
                    }
                    this.els.btnTreeWrap.textContent = savedTreeWrap ? 'No Wrap' : 'Wrap';
                },
                loadSampleData() {
                    if (!this.state.monacoEditor) return;
                    const sample = `<root>\n  <!-- This is a sample XML document -->\n  <items count="2">\n    <item id="i1">\n      <name>First Item</name>\n      <value>100</value>\n    </item>\n    <item id="i2">\n      <name>Second Item</name>\n      <value>200</value>\n    </item>\n  </items>\n</root>`;
                    this.state.monacoEditor.setValue(sample);
                    this.handlers.handleUpdateFromEditor();
                },
                bindEvents() {
                    this.els.btnValidate.addEventListener('click', () => this.handlers.handleUpdateFromEditor());
                    this.els.btnFormat.addEventListener('click', () => this.handlers.handleFormat());
                    this.els.btnBeautify.addEventListener('click', () => this.handlers.handleFormat());
                    this.els.btnCopy.addEventListener('click', () => this.handlers.handleCopy());
                    this.els.btnDownload.addEventListener('click', () => this.handlers.handleDownload());
                    this.els.btnClear.addEventListener('click', () => this.handlers.handleClear());
                    this.els.fileInput.addEventListener('change', (e) => this.handlers.handleFileSelect(e));
                    ['dragenter', 'dragover'].forEach(ev => this.els.filedrop.addEventListener(ev, this.handlers.handleDragOver));
                    ['dragleave', 'drop'].forEach(ev => this.els.filedrop.addEventListener(ev, this.handlers.handleDragLeave));
                    this.els.filedrop.addEventListener('drop', (e) => this.handlers.handleFileDrop(e));
                    this.els.btnTheme.addEventListener('click', () => this.handlers.handleThemeToggle());
                    this.els.btnWordWrap.addEventListener('click', () => this.handlers.handleWordWrapToggle());
                    this.els.btnTreeWrap.addEventListener('click', () => this.handlers.handleTreeWrapToggle());
                    this.els.search.addEventListener('input', this.utils.debounce(() => this.handlers.handleSearch(), 200));
                    this.els.splitter.addEventListener('mousedown', () => { this.state.isSplitterDown = true; document.body.style.cursor = 'col-resize'; });
                    window.addEventListener('mouseup', () => { if(this.state.isSplitterDown) { this.state.isSplitterDown = false; document.body.style.cursor = 'default'; }});
                    window.addEventListener('mousemove', (e) => this.handlers.handleSplitterMove(e));
                    window.addEventListener('keydown', (e) => this.handlers.handleKeyDown(e));
                    
                    // Visualization events
                    this.els.btnToggleNetwork.addEventListener('click', () => this.visualization.show('network'));
                    this.els.btnToggleTree.addEventListener('click', () => this.visualization.show('tree'));
                    this.els.btnCloseViz.addEventListener('click', () => {
                        this.state.pinnedVizNodeData = null;
                        this.visualization.showAttributes(null);
                        this.visualization.hide();
                    });
                    this.els.vizAttrClose.addEventListener('click', () => {
                         this.state.pinnedVizNodeData = null;
                         this.visualization.showAttributes(null);
                    });
                    this.els.btnToggleValues.addEventListener('click', () => this.els.vizSvg.node().classList.toggle('values-hidden'));
                    this.els.btnToggleFullscreen.addEventListener('click', () => this.visualization.toggleFullscreen());
                },
                handlers: {
                    handleUpdateFromEditor() {
                        const tool = XMLTool;
                        if (!tool.state.monacoEditor) return;
                        const text = tool.state.monacoEditor.getValue().trim();
                        if (text === '') {
                            tool.els.treeRoot.innerHTML = '';
                            tool.els.filedrop.style.display = 'flex';
                            tool.els.nodeCount.textContent = '0';
                            tool.ui.setStatus('');
                            tool.state.xmlDoc = null;
                            return;
                        }
                        try {
                            const xmlDoc = tool.core.parseXml(text);
                            tool.state.xmlDoc = xmlDoc;
                            tool.els.filedrop.style.display = 'none';
                            tool.treeView.render(xmlDoc);
                            if (tool.els.vizPane.style.display === 'block') {
                                tool.visualization.render();
                            }
                        } catch (e) {
                           tool.state.xmlDoc = null;
                        }
                    },
                    handleFormat() {
                        if (!XMLTool.state.monacoEditor) return;
                        const text = XMLTool.state.monacoEditor.getValue();
                        let formattedText;

                        try {
                            const xmlDoc = XMLTool.core.parseXml(text);
                            formattedText = XMLTool.core.formatXml(xmlDoc);
                        } catch (e) {
                            if (e.message && e.message.includes('Namespace prefix')) {
                                XMLTool.ui.setStatus(`Warning: ${e.message}. Attempting to format anyway.`, 'warning');
                                formattedText = XMLTool.core.formatXmlFromString(text);
                            } else {
                                return; // Fatal error already shown
                            }
                        }

                        if (formattedText) {
                            XMLTool.state.monacoEditor.setValue(formattedText);
                        }
                    },
                    handleCopy() {
                        if (!XMLTool.state.monacoEditor) return;
                        navigator.clipboard.writeText(XMLTool.state.monacoEditor.getValue())
                            .then(() => XMLTool.ui.setStatus('Copied to clipboard', 'success'))
                            .catch(() => XMLTool.ui.setStatus('Copy failed', 'error'));
                    },
                    handleDownload() {
                        if (!XMLTool.state.monacoEditor) return;
                        const blob = new Blob([XMLTool.state.monacoEditor.getValue()], { type: 'application/xml' });
                        const a = document.createElement('a');
                        a.href = URL.createObjectURL(blob);
                        a.download = 'data.xml';
                        a.click();
                        URL.revokeObjectURL(a.href);
                    },
                    handleClear() {
                        if (!XMLTool.state.monacoEditor) return;
                        XMLTool.state.monacoEditor.setValue('');
                        this.handleUpdateFromEditor();
                        XMLTool.ui.setStatus('Cleared');
                    },
                    handleFileRead(result) {
                        if (XMLTool.state.monacoEditor) {
                            XMLTool.state.monacoEditor.setValue(result);
                            this.handleUpdateFromEditor();
                        }
                    },
                    handleFileSelect(e) {
                        const file = e.target.files[0];
                        if (!file) return;
                        const reader = new FileReader();
                        reader.onload = () => this.handleFileRead(reader.result);
                        reader.readAsText(file);
                    },
                    handleDragOver(e) { e.preventDefault(); XMLTool.els.filedrop.style.borderColor = 'var(--accent)'; },
                    handleDragLeave(e) { e.preventDefault(); XMLTool.els.filedrop.style.borderColor = ''; },
                    handleFileDrop(e) {
                        e.preventDefault();
                        const file = e.dataTransfer.files[0];
                        if (!file) return;
                        const reader = new FileReader();
                        reader.onload = () => this.handleFileRead(reader.result);
                        reader.readAsText(file);
                    },
                    handleThemeToggle() {
                        const isLight = document.body.classList.contains('light-theme');
                        XMLTool.applyTheme(isLight ? 'dark' : 'light');
                    },
                    handleWordWrapToggle() {
                        if (!XMLTool.state.monacoEditor) return;
                        const options = XMLTool.state.monacoEditor.getOptions();
                        const isEnabled = options.get(monaco.editor.EditorOption.wordWrap) === 'off';
                        XMLTool.state.monacoEditor.updateOptions({ wordWrap: isEnabled ? 'on' : 'off' });
                        localStorage.setItem('xml-tool-word-wrap', isEnabled);
                        XMLTool.els.btnWordWrap.textContent = isEnabled ? 'No Wrap' : 'Word Wrap';
                    },
                    handleTreeWrapToggle() {
                        const treeContainer = XMLTool.els.treeRoot.parentElement;
                        const isWrapped = treeContainer.classList.toggle('tree-word-wrap');
                        localStorage.setItem('xml-tool-tree-wrap', isWrapped);
                        XMLTool.els.btnTreeWrap.textContent = isWrapped ? 'No Wrap' : 'Wrap';
                    },
                    handleSearch() {
                        const query = XMLTool.els.search.value.trim().toLowerCase();
                        const nodes = Array.from(XMLTool.els.treeRoot.querySelectorAll('.node-wrapper'));
                        if (query === '') {
                            nodes.forEach(node => node.style.display = '');
                            return;
                        }
                        nodes.forEach(node => {
                            const tag = node.querySelector('.node-tag')?.textContent?.trim().toLowerCase() || '';
                            const isMatch = tag.includes(query);
                            node.style.display = isMatch ? '' : 'none';
                            node.dataset.isMatch = isMatch;
                        });
                        nodes.forEach(node => {
                            if (node.dataset.isMatch === 'true') {
                                let parent = node.parentElement;
                                while (parent && parent !== XMLTool.els.treeRoot) {
                                    if (parent.classList.contains('node-wrapper')) parent.style.display = '';
                                    parent = parent.parentElement;
                                }
                            }
                        });
                    },
                    handleSplitterMove(e) {
                        if (!XMLTool.state.isSplitterDown) return;
                        const main = document.querySelector('main');
                        const rect = main.getBoundingClientRect();
                        const col = Math.max(200, Math.min(rect.width - 200, e.clientX - rect.left));
                        main.style.gridTemplateColumns = `${col}px 6px 1fr`;
                    },
                    handleKeyDown(e) {
                        if ((e.ctrlKey || e.metaKey) && e.key === 's') { e.preventDefault(); XMLTool.els.btnDownload.click(); }
                        if ((e.ctrlKey || e.metaKey) && e.key === 'Enter') { e.preventDefault(); XMLTool.els.btnFormat.click(); }
                    }
                },
                core: {
                    parseXml(text) {
                        const parser = new DOMParser();
                        const xmlDoc = parser.parseFromString(text, "application/xml");
                        const errorNode = xmlDoc.querySelector("parsererror");
                        if (errorNode) {
                            const errorMsg = errorNode.textContent.split('\n')[1] || 'Invalid XML structure';
                            XMLTool.ui.setStatus(`Invalid XML: ${errorMsg}`, 'error');
                            throw new Error(errorMsg);
                        }
                        XMLTool.ui.setStatus('Valid XML', 'success');
                        return xmlDoc;
                    },
                    formatXml(xmlDoc) {
                        const xmlString = new XMLSerializer().serializeToString(xmlDoc);
                        return this.formatXmlFromString(xmlString);
                    },
                    formatXmlFromString(xmlString) {
                        let formatted = '', indent = '';
                        const tab = '\t';
                        xmlString.split(/>\s*</).forEach(node => {
                            if (node.match(/^\/\w/)) indent = indent.substring(tab.length);
                            formatted += indent + '<' + node + '>\r\n';
                            if (node.match(/^<?\w[^>]*[^\/]$/)) indent += tab;
                        });
                        return formatted.substring(1, formatted.length - 3);
                    }
                },
                treeView: {
                    render(xmlDoc) {
                        this.container = XMLTool.els.treeRoot;
                        this.container.innerHTML = '';
                        let count = 0;
                        const tagOccurrences = {};

                        const createNodeElement = (xmlNode) => {
                            count++;
                            const nodeWrapper = document.createElement('div');
                            nodeWrapper.className = 'node-wrapper';
                            
                            const nodeHeader = document.createElement('div');
                            nodeHeader.className = 'node';

                            const hasChildren = xmlNode.children && xmlNode.children.length > 0;
                            const isExpandable = hasChildren || (xmlNode.childNodes.length > 1 && Array.from(xmlNode.childNodes).some(n => n.nodeType !== Node.TEXT_NODE || n.textContent.trim()));

                            if (isExpandable) {
                                const toggler = document.createElement('span');
                                toggler.className = 'toggler';
                                toggler.textContent = '▶';
                                nodeHeader.appendChild(toggler);
                            }

                            if (xmlNode.nodeType === Node.ELEMENT_NODE) {
                                const tagName = xmlNode.nodeName;
                                const occurrenceIndex = (tagOccurrences[tagName] || 0);
                                tagOccurrences[tagName] = occurrenceIndex + 1;
                                nodeHeader.dataset.tagName = tagName;
                                nodeHeader.dataset.occurrence = occurrenceIndex;

                                const tagSpan = document.createElement('span');
                                tagSpan.className = 'node-tag';
                                tagSpan.textContent = `<${tagName}`;
                                nodeHeader.appendChild(tagSpan);
                                
                                if (xmlNode.attributes.length > 0) {
                                    for (const attr of xmlNode.attributes) {
                                        const attrNameSpan = document.createElement('span');
                                        attrNameSpan.className = 'node-attr-name';
                                        attrNameSpan.textContent = ` ${attr.name}`;
                                        const attrValSpan = document.createElement('span');
                                        attrValSpan.className = 'node-attr-value';
                                        attrValSpan.textContent = `="${attr.value}"`;
                                        nodeHeader.append(attrNameSpan, attrValSpan);
                                    }
                                }
                                nodeHeader.appendChild(document.createTextNode(hasChildren ? '>' : ' />'));
                            } else if (xmlNode.nodeType === Node.COMMENT_NODE) {
                                const commentSpan = document.createElement('span');
                                commentSpan.className = 'node-comment';
                                commentSpan.textContent = `<!-- ${xmlNode.textContent.trim()} -->`;
                                nodeHeader.appendChild(commentSpan);
                            } else if (xmlNode.nodeType === Node.TEXT_NODE && xmlNode.textContent.trim()) {
                                const textSpan = document.createElement('span');
                                textSpan.className = 'node-text';
                                textSpan.textContent = xmlNode.textContent.trim();
                                nodeHeader.appendChild(textSpan);
                            } else {
                                return null; // Skip empty text nodes
                            }

                            nodeWrapper.appendChild(nodeHeader);
                            
                            nodeHeader.addEventListener('click', () => {
                                if (xmlNode.nodeType === Node.ELEMENT_NODE) {
                                    this.selectNodeInEditor(nodeHeader.dataset.tagName, parseInt(nodeHeader.dataset.occurrence, 10));
                                }
                            });

                            if (isExpandable) {
                                nodeWrapper.classList.add('collapsed');
                                const childrenList = document.createElement('ul');
                                xmlNode.childNodes.forEach(child => {
                                    const childElement = createNodeElement(child);
                                    if (childElement) childrenList.appendChild(childElement);
                                });
                                nodeWrapper.appendChild(childrenList);
                                
                                const toggler = nodeHeader.querySelector('.toggler');
                                if(toggler) {
                                    toggler.addEventListener('click', (e) => {
                                        e.stopPropagation();
                                        nodeWrapper.classList.toggle('collapsed');
                                    });
                                }
                            }
                            return nodeWrapper;
                        };
                        if(xmlDoc.documentElement){
                            const rootElement = createNodeElement(xmlDoc.documentElement);
                            if (rootElement) {
                                if(rootElement.classList.contains('collapsed')) rootElement.classList.remove('collapsed');
                                this.container.appendChild(rootElement);
                            }
                        }
                        XMLTool.els.nodeCount.textContent = count > 0 ? count - 1 : 0;
                    },
                    selectNodeInEditor(tagName, occurrenceIndex) {
                        const { monacoEditor } = XMLTool.state;
                        if (!monacoEditor) return;

                        const model = monacoEditor.getModel();
                        if (!model) return;

                        const searchString = `<${tagName}`;
                        const matches = model.findMatches(searchString, true, false, true, null, true);

                        if (matches[occurrenceIndex]) {
                            const range = matches[occurrenceIndex].range;
                            const selectionRange = new monaco.Range(range.startLineNumber, range.startColumn + 1, range.startLineNumber, range.startColumn + 1 + tagName.length);
                            monacoEditor.revealRangeInCenter(selectionRange, monaco.editor.ScrollType.Smooth);
                            monacoEditor.setSelection(selectionRange);
                            monacoEditor.focus();
                        }
                    }
                },
                visualization: {
                    show(vizType) {
                        XMLTool.els.vizPane.style.display = 'block';
                        XMLTool.state.currentViz = vizType;
                        this.render();
                    },
                    hide() {
                        XMLTool.els.vizPane.style.display = 'none';
                        XMLTool.state.currentViz = 'none';
                    },
                    render() {
                        if (XMLTool.state.xmlDoc && XMLTool.state.xmlDoc.documentElement) {
                            if (XMLTool.state.currentViz === 'network') this.renderNetworkGraph(XMLTool.state.xmlDoc);
                            if (XMLTool.state.currentViz === 'tree') this.renderTreeLayout(XMLTool.state.xmlDoc);
                        }
                    },
                    toggleFullscreen() {
                        const isFullscreen = XMLTool.els.vizPane.classList.toggle('fullscreen');
                        XMLTool.els.btnToggleFullscreen.textContent = isFullscreen ? 'Exit Full Screen' : 'Full Screen';
                        setTimeout(() => this.render(), 100);
                    },
                    showAttributes(data) {
                        const { vizAttrPane, vizAttrContent } = XMLTool.els;
                        if (data && data.attributes && Object.keys(data.attributes).length > 0) {
                            let html = '<table>';
                            for (const [key, value] of Object.entries(data.attributes)) {
                                html += `<tr><td>${key}</td><td>${value}</td></tr>`;
                            }
                            html += '</table>';
                            vizAttrContent.innerHTML = html;
                            vizAttrPane.style.display = 'block';
                        } else {
                            vizAttrPane.style.display = 'none';
                            vizAttrContent.innerHTML = '';
                        }
                    },
                    transformXmlToHierarchy(xmlNode, tagOccurrences) {
                        if (!xmlNode || xmlNode.nodeType === Node.COMMENT_NODE) return null;
                        if (xmlNode.nodeType === Node.TEXT_NODE && !xmlNode.textContent.trim()) return null;

                        let name = xmlNode.nodeName;
                        let value = '';
                        const attributes = {};
                        let tagName = null;
                        let occurrenceIndex = null;

                        if (xmlNode.nodeType === Node.TEXT_NODE) {
                           name = `"${xmlNode.textContent.trim()}"`;
                           value = xmlNode.textContent.trim();
                        } else if (xmlNode.nodeType === Node.ELEMENT_NODE) {
                             tagName = xmlNode.nodeName;
                             occurrenceIndex = (tagOccurrences[tagName] || 0);
                             tagOccurrences[tagName] = occurrenceIndex + 1;
                             if (xmlNode.attributes) {
                                 for (const attr of xmlNode.attributes) {
                                    attributes[attr.name] = attr.value;
                                }
                            }
                        }

                        const item = { name, value, attributes, tagName, occurrenceIndex, children: [] };
                        
                        if (xmlNode.childNodes && xmlNode.childNodes.length > 0) {
                           xmlNode.childNodes.forEach(child => {
                               const childItem = this.transformXmlToHierarchy(child, tagOccurrences);
                               if (childItem) item.children.push(childItem);
                           });
                        }
                        
                        if(item.children.length === 1 && item.children[0].value) {
                             item.value = item.children[0].value;
                             item.name += `: ${item.value}`;
                             item.children = [];
                        }

                        return item;
                    },
                    renderTreeLayout(xmlDoc) {
                        const hierarchyData = this.transformXmlToHierarchy(xmlDoc.documentElement, {});
                        const root = d3.hierarchy(hierarchyData);
                        
                        XMLTool.els.vizSvg.selectAll("*").remove();
                        XMLTool.els.vizMessage.style.display = 'none';

                        const dx = 40, dy = 220;
                        const treeLayout = d3.tree().nodeSize([dx, dy]);
                        treeLayout(root);

                        let x0 = Infinity, x1 = -x0;
                        root.each(d => {
                            if (d.x > x1) x1 = d.x;
                            if (d.x < x0) x0 = d.x;
                        });

                        const height = x1 - x0 + dx * 2;
                        const width = (root.height + 1) * dy;

                        const container = XMLTool.els.vizSvg
                            .attr("viewBox", [-dy / 1.5, x0 - dx, width + dy, height])
                            .on('click', () => {
                                XMLTool.state.pinnedVizNodeData = null;
                                this.showAttributes(null);
                            })
                            .append("g");

                        container.append('g').selectAll('path').data(root.links()).enter().append('path')
                            .attr('d', d3.linkHorizontal().x(d => d.y).y(d => d.x))
                            .attr("class", "link");

                        const node = container.append('g').selectAll('g').data(root.descendants()).enter().append('g')
                            .attr('class', 'node-viz') 
                            .attr('transform', d => `translate(${d.y},${d.x})`)
                            .on('click', (event, d) => {
                                event.stopPropagation();
                                XMLTool.state.pinnedVizNodeData = d.data;
                                this.showAttributes(d.data);
                                if (d.data.tagName) {
                                    XMLTool.treeView.selectNodeInEditor(d.data.tagName, d.data.occurrenceIndex);
                                }
                            })
                            .on('mouseover', (event, d) => {
                                this.showAttributes(d.data);
                            })
                            .on('mouseout', () => {
                                this.showAttributes(XMLTool.state.pinnedVizNodeData);
                            });

                        node.append('circle').attr('r', 6).style("fill", d => d.children && d.children.length ? 'var(--accent)' : 'var(--success)');
                        const text = node.append('text').attr('dy', '0.31em').attr('x', d => d.children && d.children.length ? -12 : 12).attr('text-anchor', d => d.children && d.children.length ? 'end' : 'start');
                        text.append("tspan").text(d => d.data.name);
                        
                        const zoom = d3.zoom().scaleExtent([0.1, Infinity]).on("zoom", (event) => {
                            container.attr("transform", event.transform);
                            XMLTool.state.treeTransform = event.transform;
                        });
                        XMLTool.els.vizSvg.call(zoom).call(zoom.transform, XMLTool.state.treeTransform);
                    },
                    transformXmlToGraphData(xmlDoc) {
                        const nodes = [], links = [];
                        let idCounter = 0;

                        function traverse(xmlNode, parentId) {
                            if (!xmlNode || xmlNode.nodeType === Node.COMMENT_NODE) return;
                            if (xmlNode.nodeType === Node.TEXT_NODE && !xmlNode.textContent.trim()) return;
                            
                            const nodeId = idCounter++;
                            let name = xmlNode.nodeName;
                            let value = '';
                            let type = 'element';
                            
                            if (xmlNode.nodeType === Node.TEXT_NODE) {
                                name = `Text`;
                                value = `: "${xmlNode.textContent.trim()}"`;
                                type = 'value';
                            }

                            nodes.push({ id: nodeId, key: name, value: value, type });
                            if (parentId !== null) links.push({ source: parentId, target: nodeId });

                            if(xmlNode.attributes) {
                                for(const attr of xmlNode.attributes){
                                    const attrId = idCounter++;
                                    nodes.push({ id: attrId, key: attr.name, value: `: "${attr.value}"`, type: 'attribute' });
                                    links.push({ source: nodeId, target: attrId });
                                }
                            }

                            if (xmlNode.childNodes) {
                                xmlNode.childNodes.forEach(child => traverse(child, nodeId));
                            }
                        }

                        traverse(xmlDoc.documentElement, null);
                        return { nodes, links };
                    },
                    renderNetworkGraph(xmlDoc) {
                        const { nodes, links } = this.transformXmlToGraphData(xmlDoc);
                        XMLTool.els.vizSvg.selectAll("*").remove();
                        XMLTool.els.vizMessage.style.display = 'none';

                        if (!nodes.length) {
                            XMLTool.els.vizMessage.textContent = 'No data to visualize.';
                            XMLTool.els.vizMessage.style.display = 'block';
                            return;
                        }

                        const width = XMLTool.els.vizPane.clientWidth, height = XMLTool.els.vizPane.clientHeight;
                        const simulation = d3.forceSimulation(nodes)
                            .force("link", d3.forceLink(links).id(d => d.id).distance(60))
                            .force("charge", d3.forceManyBody().strength(-150))
                            .force("center", d3.forceCenter(width / 2, height / 2));

                        const container = XMLTool.els.vizSvg.append("g");
                        const link = container.append("g").selectAll("line").data(links).enter().append("line").attr("class", "link");
                        const node = container.append("g").selectAll("g").data(nodes).enter().append("g")
                            .attr("class", "node-viz")
                            .call(d3.drag().on("start", dragstarted).on("drag", dragged).on("end", dragended));

                        node.append("circle").attr("r", d => d.type === 'value' ? 4 : (d.type === 'attribute' ? 5 : 8))
                            .style("fill", d => ({'element': 'var(--accent)', 'attribute': 'var(--muted)', 'value': 'var(--success)'}[d.type]));
                        const text = node.append("text").attr("x", 12).attr("dy", ".35em");
                        text.append("tspan").text(d => d.key);
                        text.append("tspan").attr("class", "value-text").text(d => d.value);

                        simulation.on("tick", () => {
                            link.attr("x1", d => d.source.x).attr("y1", d => d.source.y).attr("x2", d => d.target.x).attr("y2", d => d.target.y);
                            node.attr("transform", d => `translate(${d.x},${d.y})`);
                        });
                        
                        const zoom = d3.zoom().scaleExtent([0.1, Infinity]).on("zoom", (event) => {
                            container.attr("transform", event.transform);
                            XMLTool.state.networkTransform = event.transform;
                        });
                        XMLTool.els.vizSvg.call(zoom).call(zoom.transform, XMLTool.state.networkTransform);

                        function dragstarted(event, d) { if (!event.active) simulation.alphaTarget(0.3).restart(); d.fx = d.x; d.fy = d.y; }
                        function dragged(event, d) { d.fx = event.x; d.fy = event.y; }
                        function dragended(event, d) { if (!event.active) simulation.alphaTarget(0); d.fx = null; d.fy = null; }
                    }
                },
                ui: {
                    setStatus(msg, type = '') {
                        XMLTool.els.editorStatus.textContent = msg;
                        XMLTool.els.editorStatus.className = `status ${type}`;
                    }
                },
                utils: {
                    debounce(func, delay) {
                        let timeout;
                        return function(...args) {
                            clearTimeout(timeout);
                            timeout = setTimeout(() => func.apply(this, args), delay);
                        };
                    }
                },
                applyTheme(theme) {
                    if (theme === 'light') {
                        document.body.classList.add('light-theme');
                        this.els.btnTheme.innerHTML = this.icons.moon + ' Dark';
                        if (this.state.monacoEditor) monaco.editor.setTheme('vs');
                    } else {
                        document.body.classList.remove('light-theme');
                        this.els.btnTheme.innerHTML = this.icons.sun + ' Light';
                        if (this.state.monacoEditor) monaco.editor.setTheme('vs-dark');
                    }
                    localStorage.setItem('xml-tool-theme', theme);
                }
            };

            XMLTool.init();
        });
    </script>
</body>
</html>


